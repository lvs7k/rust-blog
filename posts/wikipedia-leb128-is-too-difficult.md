# WikipediaのLEB128の記事が難しすぎる

WebAssemblyでは整数はLEB128としてエンコードされている[^1]らしいので、LEB128とはどのようなものなのか調べてみました。
まともなソースが[Wikipediaの記事](https://en.wikipedia.org/wiki/LEB128)しか存在しないのにそれが私にとっては難解だったので、理解しようとした過程を書き残します。
正しいかどうかはわからないので、参考程度にしてください。

**目次**
- [符号なし整数のエンコード](#符号なし整数のエンコード)
  - [Wikipediaの説明1](#Wikipediaの説明1)
  - [エンコードした結果がどこで1バイトから2バイトに増えるか1](#エンコードした結果がどこで1バイトから2バイトに増えるか1)
  - [なぜ128を表現するのに2バイト必要なのか](#なぜ128を表現するのに2バイト必要なのか)
  - [Rustコード1](#Rustコード1)
- [符号なし整数のデコード](#符号なし整数のデコード)
  - [Rustコード2](#Rustコード2)
- [符号あり整数のエンコード](#符号あり整数のエンコード)
  - [Wikipediaの説明2](#Wikipediaの説明2)
  - [エンコードした結果がどこで1バイトから2バイトに増えるか2](#エンコードした結果がどこで1バイトから2バイトに増えるか2)

## 符号なし整数のエンコード

### Wikipediaの説明1

符号なし整数624485のエンコードが例として書かれています。これに関しては特に難しい部分はないと最初に読んだときは思いました。

```
MSB ------------------ LSB
      10011000011101100101  元の値の2進数表現
     010011000011101100101  7の倍数ビットに拡張
 0100110  0001110  1100101  7ビットごとに分割
00100110 10001110 11100101  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
    0x26     0x8E     0xE5  16進数表現
```

> [!NOTE]
> 「数値を7ビットの倍数になるようにゼロ拡張する」の部分を後でもっと詳しく見ていきます。

### エンコードした結果がどこで1バイトから2バイトに増えるか1

エンコードした結果がどこで1バイトから2バイトに増えるかがわかると、理解が深まるのではないかと思いました。
127までは1バイト、128からは2バイトになります。Wikipediaの例のように表現してみましょう。

符号なし整数127のエンコード
```
MSB ------------------ LSB
                   1111111  元の値の2進数表現
                   1111111  7の倍数ビットに拡張
                   1111111  7ビットごとに分割
                  01111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x7F  16進数表現
```

符号なし整数128のエンコード
```
MSB ------------------ LSB
                  10000000  元の値の2進数表現
            00000010000000  7の倍数ビットに拡張
          0000001  0000000  7ビットごとに分割
         00000001 10000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
             0x01     0x80  16進数表現
```

### なぜ128を表現するのに2バイト必要なのか

128のエンコード例において、7ビットごとに分割した一番右のグループの先頭に0をつけて、エンコード結果を0x00としたとします。
これは0をエンコードした結果と同じになってしまいデコードできません。

### Rustコード1

Wikipediaの疑似コードを参考に、Rustでu32をLEB128へエンコードする関数を書きました。

```rust
pub fn to_leb128_u32(mut value: u32) -> Vec<u8> {
    let mut result = Vec::new();

    loop {
        let byte = (value & 0b01111111) as u8;
        value >>= 7;

        if value == 0 {
            result.push(byte);
            break;
        }

        result.push(byte | 0b10000000);
    }

    result
}
```

整数128をエンコードしたときの動作のイメージはこうなります。

```
value: 00000000000000000000000010000000

ループ1
byte: 00000000
value: 00000000000000000000000000000001
value == 0 -> false
result: [10000000]

ループ2
byte: 00000001
value: 00000000000000000000000000000000
value == 0 -> true
result: [10000000, 00000001]
break

result: [10000000, 00000001]
```

Wikipediaの説明では「7の倍数ビットに拡張してから分割」となっていますが、疑似コードでは下位7ビットを取り出しながら結果を出力するようになっています。


## 符号なし整数のデコード

「7ビットごとに分割したものをバイト列にしたのだから、逆にバイト列から下位7ビットを取り出して結合すればいいよね」という方針で、Wikipediaの疑似コードは書かれています。

### Rustコード2

```rust
pub fn from_leb128_u32(input: &[u8]) -> Result<u32, String> {
    let mut result: u32 = 0;
    let mut shift: usize = 0;
    let size: usize = std::mem::size_of::<u32>() * 8;

    for &byte in input {
        result |= ((byte & 0b01111111) as u32) << shift;
        shift += 7;

        if shift >= size {
            return Err("byte sequence too long".into());
        }

        if byte & 0b10000000 == 0 {
            break;
        }
    }

    Ok(result)
}
```

整数128をデコードしたときの動作のイメージはこうなります。

```
input: [10000000, 00000001]
result: 00000000000000000000000000000000

ループ1
byte & 0b01111111: 00000000
result: 00000000000000000000000000000000
shift: 7
byte & 0b10000000 == 0 -> false

ループ2
byte & 0b01111111: 00000001
result: 00000000000000000000000010000000
shift: 14
byte & 0b10000000 == 0 -> true
break

result: 00000000000000000000000010000000
```

## 符号あり整数のエンコード

### Wikipediaの説明2

符号あり整数-123456のエンコードが例として書かれています。これがわかりづらいと感じました。-123456をエンコードするのに、開始地点が123456になっているからです。

```
MSB ------------------ LSB
         11110001001000000  123456 の2進数表現
     000011110001001000000  21ビットの
     111100001110110111111  すべてのビットを反転 (1の補数)
     111100001110111000000  1を足す(2の補数)
 1111000  0111011  1000000  7ビットごとに分割
01111000 10111011 11000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
    0x78     0xBB     0xC0  16進数表現
```

疑似コードは-123456のような負の値もそのまま処理をしているように見えます。-123456を2の補数として2進数で表現したものを開始地点とすることはできないでしょうか？

### エンコードした結果がどこで1バイトから2バイトに増えるか2

正の数の場合は63までは1バイト、64からは2バイトになります。負の数の場合は-64までは1バイト、-65からは2バイトになります。Wikipediaの例のように表現してみましょう。

符号あり整数63のエンコード
```
MSB ------------------ LSB
                   0011111  元の値の2進数表現
                   0011111  7の倍数ビットに拡張
                   0011111  7ビットごとに分割
                  01111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x3F  16進数表現
```

符号あり整数64のエンコード（誤り）
```
MSB ------------------ LSB
                   0100000  元の値の2進数表現
                   0100000  7の倍数ビットに拡張
                   0100000  7ビットごとに分割
                  01000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x40  16進数表現
```

> [!CAUTION]
> 上記の符号あり整数64のエンコードは誤りです。






[^1]: [WebAssembly Specification](https://webassembly.github.io/spec/core/binary/values.html#integers)
