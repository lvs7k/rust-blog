# WikipediaのLEB128の記事が難しすぎる

WebAssemblyでは整数はLEB128としてエンコードされている[^1]らしいので、LEB128とはどのようなものなのか調べてみました。
まともなソースが[Wikipediaの記事](https://en.wikipedia.org/wiki/LEB128)しか存在しないのにそれが私にとっては難解だったので、理解しようとした過程を書き残します。
正しいかどうかはわからないので、参考程度にしてください。

**目次**
- [符号なし整数のエンコード](#符号なし整数のエンコード)
  - [Wikipediaの説明1](#wikipediaの説明1)
  - [エンコードした結果がどこで1バイトから2バイトに増えるか1](#エンコードした結果がどこで1バイトから2バイトに増えるか1)
  - [なぜ128を表現するのに2バイト必要なのか](#なぜ128を表現するのに2バイト必要なのか)
  - [Rustコード1](#rustコード1)
- [符号なし整数のデコード](#符号なし整数のデコード)
  - [Rustコード2](#rustコード2)
- [符号あり整数のエンコード](#符号あり整数のエンコード)
  - [Wikipediaの説明2](#wikipediaの説明2)
  - [エンコードした結果がどこで1バイトから2バイトに増えるか2](#エンコードした結果がどこで1バイトから2バイトに増えるか2)
  - [符号ありの場合のビットが7の倍数となるよう拡張する方法](#符号ありの場合のビットが7の倍数となるよう拡張する方法)
  - [Rustコード3](#rustコード3)
- [符号あり整数のデコード](#符号あり整数のデコード)
  - [Rustコード4](#rustコード4)

## 符号なし整数のエンコード

### Wikipediaの説明1

符号なし整数624485のエンコードが例として書かれています。これに関しては特に難しい部分はないと最初に読んだときは思いました。

```
MSB ------------------ LSB
      10011000011101100101  元の値の2進数表現
     010011000011101100101  7の倍数ビットに拡張
 0100110  0001110  1100101  7ビットごとに分割
00100110 10001110 11100101  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
    0x26     0x8E     0xE5  16進数表現
```

> [!NOTE]
> 「数値を7ビットの倍数になるようにゼロ拡張する」の部分を後でもっと詳しく見ていきます。

### エンコードした結果がどこで1バイトから2バイトに増えるか1

エンコードした結果がどこで1バイトから2バイトに増えるかがわかると、理解が深まるのではないかと思いました。
127までは1バイト、128からは2バイトになります。Wikipediaの例のように表現してみましょう。

符号なし整数127のエンコード
```
MSB ------------------ LSB
                   1111111  元の値の2進数表現
                   1111111  7の倍数ビットに拡張
                   1111111  7ビットごとに分割
                  01111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x7F  16進数表現
```

符号なし整数128のエンコード
```
MSB ------------------ LSB
                  10000000  元の値の2進数表現
            00000010000000  7の倍数ビットに拡張
          0000001  0000000  7ビットごとに分割
         00000001 10000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
             0x01     0x80  16進数表現
```

### なぜ128を表現するのに2バイト必要なのか

128のエンコード例において、7ビットごとに分割した一番右のグループの先頭に0をつけて、エンコード結果を0x00としたとします。
これは0をエンコードした結果と同じになってしまいデコードできません。

### Rustコード1

Wikipediaの疑似コードを参考に、Rustでu32をLEB128へエンコードする関数を書きました。

```rust
pub fn to_leb128_u32(mut value: u32) -> Vec<u8> {
    let mut result = Vec::new();

    loop {
        let byte = (value & 0b01111111) as u8;
        value >>= 7;

        if value == 0 {
            result.push(byte);
            break;
        }

        result.push(byte | 0b10000000);
    }

    result
}
```

整数128をエンコードしたときの動作のイメージはこうなります。

```
value: 00000000000000000000000010000000

ループ1
byte: 00000000
value: 00000000000000000000000000000001
value == 0 -> false
result: [10000000]

ループ2
byte: 00000001
value: 00000000000000000000000000000000
value == 0 -> true
result: [10000000, 00000001]
break

result: [10000000, 00000001]
```

Wikipediaの説明では「7の倍数ビットに拡張してから分割」となっていますが、疑似コードでは下位7ビットを取り出しながら結果を出力するようになっています。


## 符号なし整数のデコード

「7ビットごとに分割したものをバイト列にしたのだから、逆にバイト列から下位7ビットを取り出して結合すればいいよね」という方針で、Wikipediaの疑似コードは書かれています。

### Rustコード2

```rust
pub fn from_leb128_u32(input: &[u8]) -> Result<u32, String> {
    let mut result: u32 = 0;
    let mut shift: usize = 0;
    let size: usize = std::mem::size_of::<u32>() * 8;

    for &byte in input {
        result |= ((byte & 0b01111111) as u32) << shift;
        shift += 7;

        if shift >= size {
            return Err("byte sequence too long".into());
        }

        if byte & 0b10000000 == 0 {
            break;
        }
    }

    Ok(result)
}
```

整数128をデコードしたときの動作のイメージはこうなります。

```
input: [10000000, 00000001]
result: 00000000000000000000000000000000

ループ1
byte & 0b01111111: 00000000
result: 00000000000000000000000000000000
shift: 7
byte & 0b10000000 == 0 -> false

ループ2
byte & 0b01111111: 00000001
result: 00000000000000000000000010000000
shift: 14
byte & 0b10000000 == 0 -> true
break

result: 00000000000000000000000010000000
```

## 符号あり整数のエンコード

### Wikipediaの説明2

符号あり整数-123456のエンコードが例として書かれています。これがわかりづらいと感じました。-123456をエンコードするのに、開始地点が123456になっているからです。

```
MSB ------------------ LSB
         11110001001000000  123456 の2進数表現
     000011110001001000000  21ビットの
     111100001110110111111  すべてのビットを反転 (1の補数)
     111100001110111000000  1を足す(2の補数)
 1111000  0111011  1000000  7ビットごとに分割
01111000 10111011 11000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
    0x78     0xBB     0xC0  16進数表現
```

疑似コードは-123456のような負の値もそのまま処理をしているように見えます。-123456を2の補数として2進数で表現したものを開始地点とすることはできないでしょうか？

### エンコードした結果がどこで1バイトから2バイトに増えるか2

正の数の場合は63までは1バイト、64からは2バイトになります。負の数の場合は-64までは1バイト、-65からは2バイトになります。Wikipediaの例のように表現してみましょう。

符号あり整数63のエンコード
```
MSB ------------------ LSB
                   0111111  元の値の2進数表現
                   0111111  7の倍数ビットに拡張
                   0111111  7ビットごとに分割
                  00111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x3F  16進数表現
```

符号あり整数64のエンコード（誤り）
```
MSB ------------------ LSB
                   1000000  元の値の2進数表現
                   1000000  7の倍数ビットに拡張
                   100000  7ビットごとに分割
                  01000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x40  16進数表現
```

> [!CAUTION]
> 上記の符号あり整数64のエンコードは誤りです。

Wikipediaの説明通りにやっていると思うのですが、なぜ誤りなのでしょうか？先に-64と-65のエンコードについて考えてみましょう。

符号あり整数-64のエンコード
```
MSB ------------------ LSB
                   1000000  64 の2進数表現
                   1000000  7ビットの
                   0111111  すべてのビットを反転 (1の補数)
                   1000000  1を足す(2の補数)
                   1000000  7ビットごとに分割
                  01000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x40  16進数表現
```

符号あり整数-65のエンコード（誤り）
```
MSB ------------------ LSB
                   1000001  65 の2進数表現
                   1000001  7ビットの
                   0111110  すべてのビットを反転 (1の補数)
                   0111111  1を足す(2の補数)
                   0111111  7ビットごとに分割
                  00111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
                      0x3F  16進数表現
```

> [!CAUTION]
> 上記の符号あり整数-65のエンコードは誤りです。

63と-65、64と-64のエンコード結果が同じとなり見分けがつかなくなってしまっています。疑似コードのロジックを追ってみると、64と-65は下記のようになるのが正しそうです。

符号あり整数64のエンコード
```
MSB ------------------ LSB
                   1000000  元の値の2進数表現
            00000001000000  7の倍数ビットに拡張
          0000000  1000000  7ビットごとに分割
         00000000 11000000  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
             0x00     0xC0  16進数表現
```

符号あり整数-65のエンコード
```
MSB ------------------ LSB
                   1000001  65 の2進数表現
            00000001000001  14ビットの
            11111110111110  すべてのビットを反転 (1の補数)
            11111110111111  1を足す(2の補数)
          1111111  0111111  7ビットごとに分割
         01111111 10111111  最後（最上位）のグループを除くすべてに高位1ビットを追加してバイトを形成
             0x7F     0xBF  16進数表現
```

Wikipediaの符号なしLEB128のエンコードについて、下記のような文があります。
> 次に数値を7ビットの倍数になるようにゼロ拡張する（数値が0でない場合、最上位7ビットがすべて0にならないようにする）。

上の64のエンコード例では最上位7ビットがすべて0になっているのですが、この拡張は問題ないのでしょうか？

### 符号ありの場合のビットが7の倍数となるよう拡張する方法

> [!WARNING]
> 間違ったことを言っているかもしれないので参考程度にしてください。

正の数の場合の拡張（例：符号あり整数63のエンコード）
```
MSB ------------------ LSB
                   0111111  元の値の2進数表現
                   0111111  7の倍数ビットに拡張
                   0111111  7ビットごとに分割
```

正の数の場合の拡張（例：符号あり整数64のエンコード）
```
MSB ------------------ LSB
                   1000000  元の値の2進数表現
            00000001000000  7の倍数ビットに拡張
          0000000  1000000  7ビットごとに分割
```

符号あり整数で正の数の場合は上位ビットに0を追加することで拡張します。最上位7ビットがすべて0になったとしても、次の7ビットの先頭のビットが1ならば拡張してよいです。

負の数の場合の拡張（例：符号あり整数-64のエンコード）
```
MSB ------------------ LSB
                   1000000  -64の2進数表現(2の補数)
                   1000000  7の倍数ビットに拡張
                   1000000  7ビットごとに分割
```

負の数の場合の拡張（例：符号あり整数-65のエンコード）
```
MSB ------------------ LSB
                  10111111  -65の2進数表現(2の補数)
            11111110111111  7の倍数ビットに拡張
          1111111  0111111  7ビットごとに分割
```

符号あり整数で正の数の場合は上位ビットに1を追加することで拡張します。最上位7ビットがすべて1になったとしても、次の7ビットの先頭のビットが0ならば拡張してよいです。

### Rustコード3

Wikipediaの疑似コードを参考に、Rustでi32をLEB128へエンコードする関数を書きました。

```rust
pub fn to_leb128_i32(mut value: i32) -> Vec<u8> {
    let mut result = Vec::new();

    loop {
        let byte = (value & 0b01111111) as u8;
        value >>= 7;

        if value == 0 && (byte & 0b01000000) == 0 || value == -1 && (byte & 0b01000000) != 0 {
            result.push(byte);
            break;
        }

        result.push(byte | 0b10000000);
    }

    result
}
```

> [!NOTE]
> Rustの右シフト演算子`>>`はarithmetic shiftです。負の数を右シフトすると、上位ビットには1が入ります。
> [The Rust Reference](https://doc.rust-lang.org/reference/expressions/operator-expr.html?highlight=arithmetic%20shift#arithmetic-and-logical-binary-operators)

ほぼ符号なし整数のときと同じです。ループの終了条件が異なる点に注意してください。
直感的な説明をすると、valueを右シフトしていってビットが全て1（つまり値が-1）となったとき、直前に取り出した7ビットの先頭ビットが1ならばループを終了し、0ならば再度ループします。
やっていることは[符号ありの場合のビットが7の倍数となるよう拡張する方法](#符号ありの場合のビットが7の倍数となるよう拡張する方法)と同じです。

## 符号あり整数のデコード

「7ビットごとに分割したものをバイト列にしたのだから、逆にバイト列から下位7ビットを取り出して結合すればいいよね」という方針は、符号なしのときと変わりません。


### Rustコード4

```rust
pub fn from_leb128_i32(input: &[u8]) -> Result<i32, String> {
    let mut result: i32 = 0;
    let mut shift: usize = 0;
    let size: usize = std::mem::size_of::<i32>() * 8;

    for &byte in input {
        result |= ((byte & 0b01111111) as i32) << shift;
        shift += 7;

        if shift >= size {
            return Err("byte sequence too long".into());
        }

        if byte & 0b10000000 == 0 {
            if byte & 0b01000000 != 0 {
                result |= !0i32 << shift;
            }
            break;
        }
    }

    Ok(result)
}
```

違いは下記の部分です。

```rust
        if byte & 0b10000000 == 0 {
            if byte & 0b01000000 != 0 {
                result |= !0i32 << shift;
            }
            break;
        }
```

`if byte & 0b10000000 == 0`は先頭ビットが0なので、エンコードした結果の最後のバイトであることを示しています。
次の`if byte & 0b01000000 != 0`では最後のバイトの上から2桁目のバイトが1かどうか、つまり負の数であるかをチェックしています。
負である場合、`result |= !0i32 << shift;`の部分で結果の上位ビットを1で埋め尽くして負の数にしています。

> [!NOTE]
> `!`はビット反転演算子です。C言語では`~`ですが、Rustでは`!`です。ここでは`0`を反転して`11111111...`というビット列を作成しています。

[^1]: [WebAssembly Specification](https://webassembly.github.io/spec/core/binary/values.html#integers)
